package ucloud

import (
	"context"
	"fmt"
	"time"

	"github.com/cenkalti/backoff/v4"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/ucloud/ucloud-sdk-go/services/ucdn"
	uerr "github.com/ucloud/ucloud-sdk-go/ucloud/error"
	"github.com/ucloud/ucloud-sdk-go/ucloud/request"
	"github.com/ucloud/ucloud-sdk-go/ucloud/response"
)

type ucloudCdnDomainResourceModel struct {
	DomainId          types.String `tfsdk:"domain_id"` // generated by ucloud
	Domain            types.String `tfsdk:"domain"`
	Cname             types.String `tfsdk:"cname"`  // generated by ucloud
	Status            types.String `tfsdk:"status"` // set by ucloud
	CreateTime        types.Int64  `tfsdk:"create_time"`
	TestUrl           types.String `tfsdk:"test_url"`
	AreaCode          types.String `tfsdk:"area_code"`
	CdnType           types.String `tfsdk:"cdn_type"`
	CdnProtocol       types.String `tfsdk:"cdn_protocol"`
	CertName          types.String `tfsdk:"cert_name"`
	HttpsStatusCn     types.String `tfsdk:"https_status_cn"`     // set by ucloud
	HttpsStatusAbroad types.String `tfsdk:"https_status_abroad"` // set by ucloud
	CertNameCn        types.String `tfsdk:"cert_name_cn"`        // set by ucloud
	CertNameAbroad    types.String `tfsdk:"cert_name_abroad"`    // set by ucloud
	Tag               types.String `tfsdk:"tag"`

	OriginConfig struct {
		OriginIpList    types.List   `tfsdk:"origin_ip_list"`
		OriginHost      types.String `tfsdk:"origin_host"`
		OriginPort      types.Int64  `tfsdk:"origin_port"`
		OriginProtocol  types.String `tfsdk:"origin_protocol"`
		OriginFollow301 types.Int64  `tfsdk:"origin_follow301"`
	} `tfsdk:"origin_conf"`

	CacheConf struct {
		CacheHost types.String `tfsdk:"cache_host"`
		CacheList []cache      `tfsdk:"cache_list"`
	} `tfsdk:"cache_conf"`

	AccessControlConfig struct {
		IpBlackList types.List `tfsdk:"ip_blacklist"`
		ReferConf   struct {
			ReferType types.Int64 `tfsdk:"refer_type"`
			NullRefer types.Int64 `tfsdk:"null_refer"`
			ReferList types.List  `tfsdk:"refer_list"`
		} `tfsdk:"refer_conf"`
		EnableRefer types.Bool `tfsdk:"enable_refer"`
	} `tfsdk:"access_control_conf"`

	AdvancedConf struct {
		HttpClientHeaderList types.List `tfsdk:"http_client_header_list"`
		HttpOriginHeaderList types.List `tfsdk:"http_origin_header_list"`
		Http2Https           types.Bool `tfsdk:"http_to_https"`
	} `tfsdk:"advanced_conf"`
}

type cache struct {
	PathPattern      types.String `tfsdk:"path_pattern"`
	Description      types.String `tfsdk:"description"`
	TTL              types.Int64  `tfsdk:"ttl"`
	CacheUnit        types.String `tfsdk:"cache_unit"`
	CacheBehavior    types.Bool   `tfsdk:"cache_behavior"`
	FollowOriginRule types.Bool   `tfsdk:"follow_origin_rule"`
}

type createDomainConfig struct {
	Domain      string
	OriginIp    []string
	OriginHost  string
	TestUrl     string
	CacheConf   []createDomainCacheConf
	AreaCode    *string
	CdnType     *string
	CdnProtocol *string
	CertName    *string
	Tag         *string
}

type createDomainCacheConf struct {
	PathPattern   string
	CacheTTL      int64
	CacheUnit     string
	CacheBehavior bool
}

type createCdnDomainRequest struct {
	request.CommonBase
	DomainList []createDomainConfig
}

type createCdnDomainResponse struct {
	response.CommonBase
	DomainList []struct {
		Domain   string `json:"Domain"`
		DomainId string `json:"DomainId"`
		RetCode  int    `json:"RetCode"`
		Message  string `json:"Message"`
	} `json:"DomainList"`
}

type ucloudCdnDomainResource struct {
	client *ucdn.UCDNClient
}

var (
	_ resource.Resource              = &ucloudCdnDomainResource{}
	_ resource.ResourceWithConfigure = &ucloudCdnDomainResource{}
	//_ resource.ResourceWithValidateConfig = &ucloudCdnDomainResource{}
)

func NewUcloudCdnDomainResource() resource.Resource {
	return &ucloudCdnDomainResource{}
}

func (r *ucloudCdnDomainResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_cdn_domain"
}

func (r *ucloudCdnDomainResource) Schema(_ context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "This resource provides the configuration of acceleration domain",
		Attributes: map[string]schema.Attribute{
			"domain_id": &schema.StringAttribute{
				Description: "Id of acceleration domain, generated by ucloud.",
				Computed:    true,
			},
			"domain": &schema.StringAttribute{
				Description: "Acceleration domain",
				Required:    true,
			},
			"cname": &schema.StringAttribute{
				Description: "Cname",
				Computed:    true,
			},
			"status": &schema.StringAttribute{
				Description: "Domain status",
				Computed:    true,
			},
			"create_time": &schema.Int64Attribute{
				Description: "Create time.",
				Computed:    true,
			},
			"test_url": &schema.StringAttribute{
				Description: "Test url",
				Optional:    true,
			},
			"area_code": &schema.StringAttribute{
				Description: "Acceleration area.`cn` represents China.`abroad` represents regions outside China.If the value is unset,domain is accelerated in all regions",
				Optional:    true,
			},
			"cdn_type": &schema.StringAttribute{
				Description: "`web` for website service,`stream` for video service,`download` for download service",
				Optional:    true,
			},
			"cdn_protocol": &schema.StringAttribute{
				Description: "`http` for only http supported, `http|https` enable https feature",
				Optional:    true,
			},
			"cert_name": &schema.StringAttribute{
				Description: "The name of certificate",
				Optional:    true,
			},
			"https_status_cn": &schema.StringAttribute{
				Description: "Https status",
				Computed:    true,
			},
			"https_status_abroad": &schema.StringAttribute{
				Description: "Https status",
				Computed:    true,
			},
			"cert_name_cn": &schema.StringAttribute{
				Description: "Certificate name.",
				Computed:    true,
			},
			"cert_name_abroad": &schema.StringAttribute{
				Description: "Certificate name.",
				Computed:    true,
			},
			"tag": &schema.StringAttribute{
				Description: "The group of service.If the value is unset. `Default` is used as default value",
				Optional:    true,
			},
			"origin_conf": &schema.SingleNestedAttribute{
				Description: "The configuration of origin",
				Attributes: map[string]schema.Attribute{
					"origin_ip_list": schema.ListAttribute{
						Description: "The ip list of origin",
						ElementType: types.StringType,
						Required:    true,
					},
					"origin_host": schema.StringAttribute{
						Description: "The host of origin",
						Optional:    true,
					},
					"origin_port": schema.Int64Attribute{
						Description: "The service port of origin",
						Optional:    true,
					},
					"origin_protocol": schema.StringAttribute{
						Description: "The protocol of origin.The optional values are `http` and `https`",
						Optional:    true,
					},
					"origin_follow301": schema.Int64Attribute{
						Description: "Whether redirect according to the url from origin.The optional values are 0 and 1",
						Optional:    true,
					},
				},
				Required: true,
			},
			"cache_conf": &schema.SingleNestedAttribute{
				Description: "The configuration of cache",
				Attributes: map[string]schema.Attribute{
					"cache_host": schema.StringAttribute{
						Description: "Cache Host",
						Optional:    true,
					},
					"cache_list": schema.ListNestedAttribute{
						Description: "The list of cache rule",
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"path_pattern": schema.StringAttribute{
									Description: "The pattern of path",
									Required:    true,
								},
								"description": schema.StringAttribute{
									Description: "The description of rule",
									Required:    true,
								},
								"ttl": schema.Int64Attribute{
									Description: "The cache time",
									Required:    true,
								},
								"cache_unit": schema.StringAttribute{
									Description: "The unit of caching time.The optional values are `sec`,`min`,`hour` and `day`.",
									Required:    true,
								},
								"cache_behavior": schema.BoolAttribute{
									Description: "If caching is enabled.The optional values are true and false.",
									Required:    true,
								},
								"follow_origin_rule": schema.BoolAttribute{
									Description: "If follow caching instructions in http header from the origin.The optional values are true and false.",
									Optional:    true,
								},
							},
						},
						Required: true,
					},
				},
				Required: true,
			},
			"access_control_conf": &schema.SingleNestedAttribute{
				Description: "The configuration of access control.",
				Attributes: map[string]schema.Attribute{
					"ip_blacklist": schema.ListAttribute{
						Description: "Request from address in blacklist will be denied.",
						ElementType: types.StringType,
						Optional:    true,
					},
					"refer_conf": schema.SingleNestedAttribute{
						Description: "",
						Attributes: map[string]schema.Attribute{
							"refer_type": schema.Int64Attribute{
								Description: "The type of anti-leech rules.If the value is 0,`refer_list` is whitelist,requests with these refers will be allowed.If the value is 1,`refer_list` is blacklist,requests with these refers will be denied.",
								Optional:    true,
							},
							"null_refer": schema.Int64Attribute{
								Description: "When `refer_type` is 0,if the value is 0,NULL refer requests are not allowed.",
								Optional:    true,
							},
							"refer_list": schema.ListAttribute{
								Description: "The anti-leech rule list",
								ElementType: types.StringType,
								Optional:    true,
							},
						},
						Required: true,
					},
					"enable_refer": schema.BoolAttribute{
						Description: "Whether enable refer.",
						Optional:    true,
					},
				},
				Required: true,
			},
			"advanced_conf": &schema.SingleNestedAttribute{
				Description: "The advance configuration.",
				Attributes: map[string]schema.Attribute{
					"http_client_header_list": schema.ListAttribute{
						Description: "Add http header when send response to client.",
						ElementType: types.StringType,
						Optional:    true,
					},
					"http_origin_header_list": schema.ListAttribute{
						Description: "Add http header when send request to origin",
						ElementType: types.StringType,
						Optional:    true,
					},
					"http_to_https": schema.BoolAttribute{
						Description: "If perform a forced conversion from http to https.",
						Optional:    true,
					},
				},
				Required: true,
			},
		},
	}
}

func (r *ucloudCdnDomainResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	r.client = req.ProviderData.(ucloudClients).cdnClient
}

func (r *ucloudCdnDomainResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var (
		model                   ucloudCdnDomainResourceModel
		createCdnDomainResponse createCdnDomainResponse
	)

	resp.Diagnostics.Append(req.Plan.Get(ctx, &model)...)
	if resp.Diagnostics.HasError() {
		return
	}
	createCdnDomainRequest, diags := r.createCdnDomainRequest(&model)
	if diags.HasError() {
		resp.Diagnostics.Append(diags...)
		return
	}

	var err error
	createCdnDomain := func() error {
		err = r.client.InvokeAction("BatchCreateNewUcdnDomain", createCdnDomainRequest, &createCdnDomainResponse)
		if err != nil {
			if cErr, ok := err.(uerr.ClientError); ok && cErr.Retryable() {
				return err
			}
			return backoff.Permanent(err)
		}

		if createCdnDomainResponse.RetCode != 0 {
			return backoff.Permanent(fmt.Errorf("%s", createCdnDomainResponse.Message))
		}
		if len(createCdnDomainResponse.DomainList) == 0 {
			return backoff.Permanent(fmt.Errorf("%s", "domain list is empty"))
		}
		if createCdnDomainResponse.DomainList[0].RetCode != 0 {
			return backoff.Permanent(fmt.Errorf("%s", createCdnDomainResponse.DomainList[0].Message))
		}

		return nil
	}
	reconnectBackoff := backoff.NewExponentialBackOff()
	reconnectBackoff.MaxElapsedTime = 30 * time.Second
	err = backoff.Retry(createCdnDomain, reconnectBackoff)
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to Create CdnDomain", err.Error())
		return
	}
	model.DomainId = types.StringValue(createCdnDomainResponse.DomainList[0].DomainId)

	// update other values computed by cdn
	getUcdnDomainConfigRequest := ucdn.GetUcdnDomainConfigRequest{
		CommonBase: request.CommonBase{
			ProjectId: &r.client.GetConfig().ProjectId,
		},
		DomainId: []string{model.DomainId.ValueString()},
	}
	var getUcdnDomainConfigResponse *ucdn.GetUcdnDomainConfigResponse
	getDomainConfig := func() error {
		getUcdnDomainConfigResponse, err = r.client.GetUcdnDomainConfig(&getUcdnDomainConfigRequest)
		if err != nil {
			if cErr, ok := err.(uerr.ClientError); ok && cErr.Retryable() {
				return err
			}
			return backoff.Permanent(err)
		}
		if getUcdnDomainConfigResponse.RetCode != 0 {
			return backoff.Permanent(fmt.Errorf("%s", getUcdnDomainConfigResponse.Message))
		}
		if len(getUcdnDomainConfigResponse.DomainList) == 0 {
			return backoff.Permanent(fmt.Errorf("%s", "Domain list is empty"))
		}
		return nil
	}
	err = backoff.Retry(getDomainConfig, reconnectBackoff)
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to Read CdnDomain", err.Error())
		return
	}
	updateUcloudCdnDomainResourceModelComputeFields(&model, &getUcdnDomainConfigResponse.DomainList[0])

	resp.State.Set(ctx, model)
}

func (r *ucloudCdnDomainResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var model ucloudCdnDomainResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &model)...)
	if resp.Diagnostics.HasError() {
		return
	}

	getUcdnDomainConfigRequest := ucdn.GetUcdnDomainConfigRequest{
		CommonBase: request.CommonBase{
			ProjectId: &r.client.GetConfig().ProjectId,
		},
		DomainId: []string{model.DomainId.ValueString()},
	}

	var (
		getUcdnDomainConfigResponse *ucdn.GetUcdnDomainConfigResponse
		err                         error
	)
	getDomainConfig := func() error {
		getUcdnDomainConfigResponse, err = r.client.GetUcdnDomainConfig(&getUcdnDomainConfigRequest)
		if err != nil {
			if cErr, ok := err.(uerr.ClientError); ok && cErr.Retryable() {
				return err
			}
			return backoff.Permanent(err)
		}
		if getUcdnDomainConfigResponse.RetCode != 0 {
			return backoff.Permanent(fmt.Errorf("%s", getUcdnDomainConfigResponse.Message))
		}
		if len(getUcdnDomainConfigResponse.DomainList) == 0 {
			return backoff.Permanent(fmt.Errorf("%s", "Domain list is empty"))
		}
		return nil
	}
	reconnectBackoff := backoff.NewExponentialBackOff()
	reconnectBackoff.MaxElapsedTime = 30 * time.Second
	err = backoff.Retry(getDomainConfig, reconnectBackoff)
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to Read CdnDomain", err.Error())
		return
	}

	domainConfigInfo := getUcdnDomainConfigResponse.DomainList[0]

	resp.Diagnostics.Append(updateUcloudCdnDomainResourceModel(ctx, &model, &domainConfigInfo)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &model)...)
}

func (r *ucloudCdnDomainResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var (
		model                   ucloudCdnDomainResourceModel
		state                   ucloudCdnDomainResourceModel
		updateCdnDomainResponse response.CommonBase
	)

	resp.Diagnostics.Append(req.Plan.Get(ctx, &model)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}
	model.DomainId = state.DomainId

	var err error
	reconnectBackoff := backoff.NewExponentialBackOff()
	reconnectBackoff.MaxElapsedTime = 30 * time.Second
	// update https config
	if model.CdnProtocol != state.CdnProtocol || model.CertName != state.CertName {
		updateCdnHttpsRequest := updateCdnHttpsRequest{
			CommonBase: request.CommonBase{
				ProjectId: &r.client.GetConfig().ProjectId,
			},
			Region:   r.client.GetConfig().Region,
			Zone:     r.client.GetConfig().Zone,
			Areacode: model.AreaCode.ValueString(),
			DomainId: model.DomainId.ValueString(),
		}
		if model.CdnProtocol.ValueString() == "http" {
			updateCdnHttpsRequest.HttpsStatus = "disable"
		} else if model.CdnProtocol.ValueString() == "http|https" {
			updateCdnHttpsRequest.HttpsStatus = "enable"
		}
		updateCdnHttpsRequest.CertName = model.CertName.ValueString()

		var updateCdnHttpsResponse response.CommonBase
		updateDomainHttpsConfig := func() error {
			err = r.client.InvokeAction("UpdateUcdnDomainHttpsConfig", &updateCdnHttpsRequest, &updateCdnHttpsResponse)
			if err != nil {
				if cErr, ok := err.(uerr.ClientError); ok && cErr.Retryable() {
					return err
				}
				return backoff.Permanent(err)
			}
			if updateCdnHttpsResponse.RetCode != 0 {
				return backoff.Permanent(fmt.Errorf("%s", updateCdnHttpsResponse.Message))
			}
			return nil
		}
		err = backoff.Retry(updateDomainHttpsConfig, reconnectBackoff)
		if err != nil {
			resp.Diagnostics.AddError("[API ERROR] Fail to update https config", err.Error())
			return
		}
	}
	// update domain config excludes https
	updateDomainConfig := func() error {
		err = r.client.InvokeAction("UpdateUcdnDomainConfig", r.updateCdnDomainRequest(&model), &updateCdnDomainResponse)
		if err != nil {
			if cErr, ok := err.(uerr.ClientError); ok && cErr.Retryable() {
				return err
			}
			return backoff.Permanent(err)
		}
		if updateCdnDomainResponse.RetCode != 0 && updateCdnDomainResponse.RetCode != 44015 {
			return backoff.Permanent(fmt.Errorf("%s", updateCdnDomainResponse.Message))
		}
		return nil
	}
	err = backoff.Retry(updateDomainConfig, reconnectBackoff)
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to Update CdnDomain", err.Error())
		return
	}

	copyUcloudCdnDomainResourceModelComputeFields(&model, &state)

	resp.State.Set(ctx, model)
}

func (r *ucloudCdnDomainResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var (
		model                          *ucloudCdnDomainResourceModel
		updateUcdnDomainStatusResponse response.CommonBase
	)
	resp.Diagnostics.Append(req.State.Get(ctx, &model)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateUcdnDomainStatusRequest := &struct {
		request.CommonBase
		DomainId string
		Status   string
		IsDcdn   bool
	}{
		CommonBase: request.CommonBase{
			ProjectId: &r.client.GetConfig().ProjectId,
		},
		DomainId: model.DomainId.ValueString(),
		Status:   "delete",
		IsDcdn:   false,
	}

	var err error
	updateDomainStatus := func() error {
		err = r.client.InvokeAction("UpdateUcdnDomainStatus", updateUcdnDomainStatusRequest, &updateUcdnDomainStatusResponse)
		if err != nil {
			if cErr, ok := err.(uerr.ClientError); ok && cErr.Retryable() {
				return err
			}
			return backoff.Permanent(err)
		}
		if updateUcdnDomainStatusResponse.RetCode != 0 {
			return backoff.Permanent(fmt.Errorf("%s", updateUcdnDomainStatusResponse.Message))
		}
		return nil
	}
	reconnectBackoff := backoff.NewExponentialBackOff()
	reconnectBackoff.MaxElapsedTime = 30 * time.Second
	err = backoff.Retry(updateDomainStatus, reconnectBackoff)
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to Update CdnDomain", err.Error())
		return
	}
}

/*
func (r *ucloudCdnDomainResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var model ucloudCdnDomainResourceModel

	resp.Diagnostics.Append(req.Config.Get(ctx, &model)...)
	if resp.Diagnostics.HasError() {
		return
	}

	if strings.Contains(model.CdnProtocol.ValueString(), "https") && model.CertName.ValueString() == "" {
		resp.Diagnostics.AddAttributeError(path.Root("cert_name"),
			"Missing Attribute Configuration",
			"`cert_name` should not be empty when https is enabled")
	}
}
*/

func (r *ucloudCdnDomainResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("domain"), req, resp)
}

func (r *ucloudCdnDomainResource) createCdnDomainRequest(m *ucloudCdnDomainResourceModel) (*createCdnDomainRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	domainConfig := createDomainConfig{}
	domainConfig.Domain = m.Domain.ValueString()
	diags.Append(m.OriginConfig.OriginIpList.ElementsAs(nil, &domainConfig.OriginIp, false)...)
	domainConfig.OriginHost = m.OriginConfig.OriginHost.ValueString()
	domainConfig.TestUrl = m.TestUrl.ValueString()
	domainConfig.CacheConf = make([]createDomainCacheConf, 0)
	for _, c := range m.CacheConf.CacheList {
		cc := createDomainCacheConf{}
		cc.PathPattern = c.PathPattern.ValueString()
		cc.CacheTTL = c.TTL.ValueInt64()
		cc.CacheUnit = c.CacheUnit.ValueString()
		cc.CacheBehavior = c.CacheBehavior.ValueBool()
		domainConfig.CacheConf = append(domainConfig.CacheConf, cc)
	}
	domainConfig.AreaCode = m.AreaCode.ValueStringPointer()
	domainConfig.CdnType = m.CdnType.ValueStringPointer()
	domainConfig.CdnProtocol = m.CdnProtocol.ValueStringPointer()
	domainConfig.CertName = m.CertName.ValueStringPointer()
	domainConfig.Tag = m.TestUrl.ValueStringPointer()

	return &createCdnDomainRequest{
		CommonBase: request.CommonBase{
			ProjectId: &r.client.GetConfig().ProjectId,
		},
		DomainList: []createDomainConfig{domainConfig},
	}, diags
}

func updateUcloudCdnDomainResourceModelComputeFields(model *ucloudCdnDomainResourceModel, info *ucdn.DomainConfigInfo) {
	model.DomainId = types.StringValue(info.DomainId)
	model.Cname = types.StringValue(info.Cname)
	model.Status = types.StringValue(info.Status)
	model.CreateTime = types.Int64Value(int64(info.CreateTime))
	model.HttpsStatusCn = types.StringValue(info.HttpsStatusCn)
	model.HttpsStatusAbroad = types.StringValue(info.HttpsStatusAbroad)
	model.CertNameCn = types.StringValue(info.CertNameCn)
	model.CertNameAbroad = types.StringValue(info.CertNameAbroad)
}

func copyUcloudCdnDomainResourceModelComputeFields(dst, src *ucloudCdnDomainResourceModel) {
	dst.DomainId = src.DomainId
	dst.Cname = src.Cname
	dst.Status = src.Status
	dst.CreateTime = src.CreateTime
	dst.HttpsStatusCn = src.HttpsStatusCn
	dst.HttpsStatusAbroad = src.HttpsStatusAbroad
	dst.CertNameCn = src.CertNameCn
	dst.CertNameAbroad = src.CertNameAbroad
}

func updateUcloudCdnDomainResourceModel(ctx context.Context, model *ucloudCdnDomainResourceModel, info *ucdn.DomainConfigInfo) diag.Diagnostics {
	var diags, result diag.Diagnostics

	model.AreaCode = types.StringValue(info.AreaCode)
	model.CdnType = types.StringValue(info.CdnType)
	model.Status = types.StringValue(info.Status)
	model.Cname = types.StringValue(info.Cname)
	model.CreateTime = types.Int64Value(int64(info.CreateTime))
	model.TestUrl = types.StringValue(info.TestUrl)
	model.HttpsStatusCn = types.StringValue(info.HttpsStatusCn)
	model.HttpsStatusAbroad = types.StringValue(info.HttpsStatusAbroad)
	model.CertNameCn = types.StringValue(info.CertNameCn)
	model.CertNameAbroad = types.StringValue(info.CertNameAbroad)

	model.OriginConfig.OriginIpList, diags = types.ListValueFrom(ctx, types.StringType, info.OriginConf.OriginIpList)
	result.Append(diags...)
	model.OriginConfig.OriginHost = types.StringValue(info.OriginConf.OriginHost)
	model.OriginConfig.OriginPort = types.Int64Value(int64(info.OriginConf.OriginPort))
	model.OriginConfig.OriginProtocol = types.StringValue(info.OriginConf.OriginProtocol)
	model.OriginConfig.OriginFollow301 = types.Int64Value(int64(info.OriginConf.OriginFollow301))

	model.AccessControlConfig.IpBlackList, diags = types.ListValueFrom(ctx, types.StringType, info.AccessControlConf.IpBlackList)
	result.Append(diags...)
	model.AccessControlConfig.ReferConf.ReferType = types.Int64Value(int64(info.AccessControlConf.ReferConf.ReferType))
	model.AccessControlConfig.ReferConf.NullRefer = types.Int64Value(int64(info.AccessControlConf.ReferConf.NullRefer))
	model.AccessControlConfig.ReferConf.ReferList, diags = types.ListValueFrom(ctx, types.StringType, info.AccessControlConf.ReferConf.ReferList)
	result.Append(diags...)

	model.CacheConf.CacheHost = types.StringValue(info.CacheConf.CacheHost)
	model.CacheConf.CacheList = make([]cache, 0)
	for _, conf := range info.CacheConf.CacheList {
		c := cache{
			PathPattern:      types.StringValue(conf.PathPattern),
			Description:      types.StringValue(conf.Description),
			TTL:              types.Int64Value(int64(conf.CacheTTL)),
			CacheUnit:        types.StringValue(conf.CacheUnit),
			CacheBehavior:    types.BoolValue(conf.CacheBehavior),
			FollowOriginRule: types.BoolValue(conf.FollowOriginRule),
		}
		model.CacheConf.CacheList = append(model.CacheConf.CacheList, c)
	}

	model.AdvancedConf.HttpClientHeaderList, diags = types.ListValueFrom(ctx, types.StringType, info.AdvancedConf.HttpClientHeader)
	result.Append(diags...)
	model.AdvancedConf.HttpOriginHeaderList, diags = types.ListValueFrom(ctx, types.StringType, info.AdvancedConf.HttpOriginHeader)
	result.Append(diags...)
	model.AdvancedConf.Http2Https = types.BoolValue(info.AdvancedConf.Http2Https)

	return result
}

type updateCdnHttpsRequest struct {
	request.CommonBase
	Region      string
	Zone        string
	Areacode    string
	DomainId    string
	HttpsStatus string
	CertName    string
}

type updateCdnOriginConfig struct {
	OriginHost      *string
	OriginPort      *int64
	OriginProtocol  *string
	OriginFollow301 *int64
}

type updateCdnAccessControlConfig struct {
	IpBlackList []string

	ReferConf struct {
		ReferType *int64
		NullRefer *int64
		ReferList []string
	}
	EnableRefer bool
}

type updateCdnCache struct {
	PathPattern      string
	Description      *string
	TTL              int64
	CacheUnit        string
	CacheBehavior    bool
	FollowOriginRule *bool
}

type updateCdnCacheConfig struct {
	CacheHost *string
	CacheList []updateCdnCache
}

type updateCdnAdvancedConfig struct {
	HttpClientHeader []string
	HttpOriginHeader []string
	Http2Https       *bool
}

type updateCdnDomainConfig struct {
	DomainId string

	OriginConf        updateCdnOriginConfig
	AccessControlConf updateCdnAccessControlConfig
	CacheConf         updateCdnCacheConfig
	AdvancedConf      updateCdnAdvancedConfig
}

type updateCdnDomainRequest struct {
	request.CommonBase

	DomainList []updateCdnDomainConfig
}

func (r *ucloudCdnDomainResource) updateCdnDomainRequest(m *ucloudCdnDomainResourceModel) *updateCdnDomainRequest {
	domainConf := updateCdnDomainConfig{}
	domainConf.DomainId = m.DomainId.ValueString()
	// origin
	domainConf.OriginConf.OriginHost = m.OriginConfig.OriginHost.ValueStringPointer()
	domainConf.OriginConf.OriginPort = m.OriginConfig.OriginPort.ValueInt64Pointer()
	domainConf.OriginConf.OriginProtocol = m.OriginConfig.OriginProtocol.ValueStringPointer()
	domainConf.OriginConf.OriginFollow301 = m.OriginConfig.OriginFollow301.ValueInt64Pointer()
	// access control
	m.AccessControlConfig.IpBlackList.ElementsAs(nil, &domainConf.AccessControlConf.IpBlackList, false)
	domainConf.AccessControlConf.ReferConf.NullRefer = m.AccessControlConfig.ReferConf.NullRefer.ValueInt64Pointer()
	domainConf.AccessControlConf.ReferConf.ReferType = m.AccessControlConfig.ReferConf.ReferType.ValueInt64Pointer()
	domainConf.AccessControlConf.EnableRefer = *m.AccessControlConfig.EnableRefer.ValueBoolPointer()
	m.AccessControlConfig.ReferConf.ReferList.ElementsAs(nil, &domainConf.AccessControlConf.ReferConf.ReferList, false)
	// cache control
	domainConf.CacheConf.CacheHost = m.CacheConf.CacheHost.ValueStringPointer()
	domainConf.CacheConf.CacheList = make([]updateCdnCache, 0)
	for _, c := range m.CacheConf.CacheList {
		uc := updateCdnCache{}
		uc.PathPattern = c.PathPattern.ValueString()
		uc.TTL = c.TTL.ValueInt64()
		uc.FollowOriginRule = c.FollowOriginRule.ValueBoolPointer()
		uc.Description = c.Description.ValueStringPointer()
		uc.CacheUnit = c.CacheUnit.ValueString()
		uc.CacheBehavior = c.CacheBehavior.ValueBool()
		domainConf.CacheConf.CacheList = append(domainConf.CacheConf.CacheList, uc)
	}
	// advanced config
	domainConf.AdvancedConf.Http2Https = m.AdvancedConf.Http2Https.ValueBoolPointer()
	m.AdvancedConf.HttpClientHeaderList.ElementsAs(nil, &domainConf.AdvancedConf.HttpClientHeader, false)
	m.AdvancedConf.HttpOriginHeaderList.ElementsAs(nil, &domainConf.AdvancedConf.HttpOriginHeader, false)

	return &updateCdnDomainRequest{
		CommonBase: request.CommonBase{
			ProjectId: &r.client.GetConfig().ProjectId,
		},
		DomainList: []updateCdnDomainConfig{domainConf},
	}
}
